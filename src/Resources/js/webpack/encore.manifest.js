const fs = require('fs');
const path = require('path');
const {execSync} = require('child_process');
const Encore = require('@symfony/webpack-encore');
const webpack = require('webpack');
const FosRouting = require('fos-router/webpack/FosRouting');
const VirtualModules = require('webpack-virtual-modules');
const {objectMergeDeep} = require('@wexample/js-helpers/Helper/Object');
const {stringToKebabCase} = require('@wexample/js-helpers/Helper/String');
const {
  COLORS,
  logTitle,
  logEntry,
  logPath,
} = require('@wexample/js-helpers/Helper/Log');

const DEFAULT_OUTPUT_PATH = 'public/build/';
const DEFAULT_PUBLIC_PATH = '/build';
const DEFAULT_MANIFEST_PATH = path.resolve(process.cwd(), 'assets', 'encore.manifest.json');
const WRAPPER_VIRTUAL_ROOT = path.resolve(process.cwd(), '.encore', 'virtual', 'wrappers');
const WRAPPER_TEMPLATE_PATH = path.resolve(__dirname, 'templates', 'wrapper.js.tpl');

let virtualModulesInstance = null;
let pendingVirtualModules = {};
let wrapperTemplateContent = null;

function maybeGenerateEncoreManifest(options = {}) {
  if (options.generateEncoreManifest === false) {
    return;
  }

  const consolePath = path.resolve(process.cwd(), 'bin', 'console');
  if (!fs.existsSync(consolePath)) {
    return;
  }

  execSync(
    options.generateEncoreManifestCommand || 'php bin/console loader:generate-encore-manifest',
    {stdio: 'inherit'}
  );
}

function configureEncoreBase(options = {}) {
  const env = options.env || process.env.NODE_ENV || 'dev';

  if (!Encore.isRuntimeEnvironmentConfigured()) {
    Encore.configureRuntimeEnvironment(env);
  }

  const isProd = Encore.isProduction();
  const loaderConfig = objectMergeDeep({
    sass: {
      additionalData: null,
      sassOptions: {
        quietDeps: true,
      },
    },
    css: {
      modules: false,
      esModule: true,
    },
    postcss: {
      enabled: true,
      postcssOptions: null,
    },
    vue: {
      runtimeCompilerBuild: true,
      loaderOptions: {},
    },
    ts: {
      onlyCompileBundledFiles: true,
      transpileOnly: false,
      configFile: undefined,
      compilerOptions: {},
    },
  }, options.loaders || {});

  // Allow Symfony-side config to drive the TS config file (generated by loader:generate-encore-manifest)
  if (!loaderConfig.ts.configFile && fs.existsSync(DEFAULT_MANIFEST_PATH)) {
    try {
      const loaderRuntimeConfig = JSON.parse(fs.readFileSync(DEFAULT_MANIFEST_PATH, 'utf8'));
      if (loaderRuntimeConfig && typeof loaderRuntimeConfig.tsconfigPath === 'string' && loaderRuntimeConfig.tsconfigPath.length) {
        loaderConfig.ts.configFile = loaderRuntimeConfig.tsconfigPath;
      }
    } catch (e) {
      // Ignore invalid manifest file and keep default tsconfig resolution.
    }
  }

  if (options.dumpFosRoutes !== false) {
    execSync(options.fosCommand || 'php bin/console fos:js-routing:dump', {
      stdio: 'inherit',
    });
  }

  Encore
    .setOutputPath(options.outputPath || DEFAULT_OUTPUT_PATH)
    .setPublicPath(options.publicPath || DEFAULT_PUBLIC_PATH)
    .enableSingleRuntimeChunk()
    .cleanupOutputBeforeBuild()
    .enableBuildNotifications()
    .enableSourceMaps(options.sourceMaps ?? !isProd)
    .enableVersioning(options.versioning ?? isProd)
    .addPlugin(new webpack.DefinePlugin({
      __VUE_OPTIONS_API__: true,
      __VUE_PROD_DEVTOOLS__: false,
      __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: false,
    }))
    .addPlugin(new FosRouting())
    .enableSassLoader((loaderOptions) => {
      const additionalData = loaderConfig.sass.additionalData;

      if (additionalData) {
        if (typeof additionalData === 'function') {
          loaderOptions.additionalData = additionalData(loaderOptions.additionalData || '');
        } else {
          loaderOptions.additionalData = `${additionalData}\n${loaderOptions.additionalData || ''}`.trim();
        }
      }

      loaderOptions.sassOptions = objectMergeDeep(
        loaderOptions.sassOptions || {},
        loaderConfig.sass.sassOptions || {}
      );
    })
    .enableTypeScriptLoader((tsOptions) => {
      tsOptions.onlyCompileBundledFiles = loaderConfig.ts.onlyCompileBundledFiles !== false;
      tsOptions.transpileOnly = loaderConfig.ts.transpileOnly === true;

      const compilerOptions = objectMergeDeep({}, loaderConfig.ts.compilerOptions || {});

      if (!isProd && options.enableTsSourceMaps !== false) {
        compilerOptions.sourceMap = true;
      }

      tsOptions.compilerOptions = compilerOptions;

      if (loaderConfig.ts.configFile) {
        tsOptions.configFile = loaderConfig.ts.configFile;
      }
    })
    .enableIntegrityHashes(options.integrity ?? isProd);

  Encore.configureCssLoader((cssOptions) => {
    cssOptions.esModule = loaderConfig.css.esModule !== false;
    cssOptions.modules = loaderConfig.css.modules || false;
  });

  if (loaderConfig.postcss.enabled !== false) {
    Encore.enablePostCssLoader((postCssOptions) => {
      if (loaderConfig.postcss.postcssOptions) {
        postCssOptions.postcssOptions = loaderConfig.postcss.postcssOptions;
      }
    });
  }

  Encore.enableVueLoader(
    (vueLoaderOptions) => {
      Object.assign(vueLoaderOptions, loaderConfig.vue.loaderOptions || {});
    },
    {
      runtimeCompilerBuild: loaderConfig.vue.runtimeCompilerBuild !== false,
    }
  );

  Encore.configureWatchOptions((watchOptions) => {
    watchOptions.aggregateTimeout = watchOptions.aggregateTimeout ?? 200;
    watchOptions.poll = watchOptions.poll ?? false;
    watchOptions.ignored = watchOptions.ignored ?? /node_modules/;
  });

  if (typeof options.configureEncore === 'function') {
    options.configureEncore(Encore);
  }

  logTitle(`Encore base configured (${isProd ? 'prod' : 'dev'})`);

  return Encore;
}

function applyManifestEntries(options = {}) {
  const manifestPath = path.resolve(
    process.cwd(),
    options.manifestPath || DEFAULT_MANIFEST_PATH
  );
  const manifest = options.manifest || loadManifest(manifestPath);
  const encore = options.encore || Encore;
  const seenEntries = new Set();

  logTitle(`Manifest ${path.relative(process.cwd(), manifestPath)}`);
  logPath('  Version', `${manifest.version || '?'}`);
  logPath('  Fronts ', `${manifest.frontCount ?? manifest.fronts?.length ?? 0}`);
  logFronts(manifest.fronts || []);

  addAliasesFromManifest(manifest, encore);
  registerCssEntries(manifest, encore, seenEntries);
  registerJsEntries(manifest, encore, seenEntries, options);
  finalizeVirtualModules(encore);

  return manifest;
}

function logFronts(fronts) {
  if (!fronts.length) {
    return;
  }

  logTitle('Front paths', COLORS.yellow);
  fronts.forEach((front) => {
    const label = `${front.bundle} (${front.key})`;
    const rel = front.paths?.relative || front.paths?.absolute || '';
    logPath(`  ${label}`, rel);
  });
}

function loadManifest(filePath = DEFAULT_MANIFEST_PATH) {
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `[encore-manifest] Missing manifest at ${filePath}. ` +
      'Run "php bin/console loader:generate-encore-manifest" first.'
    );
  }

  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function addAliasesFromManifest(manifest, encore) {
  const aliases = manifest.aliases || {};
  const jsDevAliases = manifest.jsDevAliases || {};
  const resolvedAliases = {};

  // Add regular aliases (relative paths)
  Object.entries(aliases).forEach(([alias, relPath]) => {
    resolvedAliases[alias] = path.resolve(process.cwd(), relPath);
  });

  // Add JS dev packages aliases (absolute paths)
  Object.entries(jsDevAliases).forEach(([alias, absPath]) => {
    resolvedAliases[alias] = absPath;
  });

  const aliasesCount = Object.keys(resolvedAliases).length;
  const jsDevCount = Object.keys(jsDevAliases).length;

  if (aliasesCount) {
    logTitle(`Aliases (${aliasesCount}${jsDevCount ? `, ${jsDevCount} dev` : ''})`, COLORS.blue);
    encore.addAliases(resolvedAliases);
    Object.entries(resolvedAliases).forEach(([alias, target]) => {
      logPath(`  ${alias}`, target);
    });
  }
}

function registerCssEntries(manifest, encore, seenEntries) {
  const cssEntries = manifest.entries?.css || [];

  if (cssEntries.length) {
    logTitle(`CSS entries (${cssEntries.length})`, COLORS.magenta);
  }

  cssEntries.forEach((entry) => {
    if (seenEntries.has(entry.output)) {
      return;
    }

    encore.addStyleEntry(
      entry.output,
      resolveSourcePath(entry.source)
    );
    seenEntries.add(entry.output);
    logEntry('style', entry);
  });
}

function registerJsEntries(manifest, encore, seenEntries, options) {
  const jsEntries = manifest.entries?.js || {};

  const categories = Object.keys(jsEntries);
  if (categories.length) {
    logTitle('JS entries', COLORS.magenta);
  }

  Object.values(jsEntries).forEach((categoryEntries) => {
    (categoryEntries || []).forEach((entry) => {
      if (seenEntries.has(entry.output)) {
        return;
      }

      let entrySource = resolveSourcePath(entry.source);

      if (entry.wrapper) {
        entrySource = buildWrapper(entry, entrySource, options, encore);
      }

      encore.addEntry(entry.output, entrySource);
      seenEntries.add(entry.output);
      logEntry(entry.wrapper ? `entry+wrapper (${entry.wrapper.type})` : 'entry', entry);
    });
  });
}

function resolveSourcePath(source) {
  const absolutePath = path.resolve(process.cwd(), source);

  if (!fs.existsSync(absolutePath)) {
    throw new Error(`[encore-manifest] Missing asset source ${absolutePath}`);
  }

  return absolutePath;
}

function buildWrapper(entry, absoluteSource, options = {}, encore = Encore) {
  const wrapperContent = renderWrapperTemplate(
    toPosix(absoluteSource),
    entry.wrapper.className
  );
  const modulePath = buildWrapperVirtualPath(entry, options);
  pendingVirtualModules[modulePath] = wrapperContent;
  logPath('    wrapper (virtual)', modulePath);

  return modulePath;
}

function buildWrapperVirtualPath(entry, options) {
  const relativeDir = sanitizeRelativeDir(entry.relative);
  const targetDir = path.join(options.virtualWrapperRoot || WRAPPER_VIRTUAL_ROOT, relativeDir);

  return path.join(targetDir, `${stringToKebabCase(buildWrapperBaseName(entry))}.js`);
}

function buildWrapperBaseName(entry) {
  if (entry.relative && entry.relative.length) {
    return path.basename(entry.relative);
  }

  return entry.output || 'index';
}

function finalizeVirtualModules(encore, options = {}) {
  const modules = pendingVirtualModules;
  pendingVirtualModules = {};

  if (!Object.keys(modules).length) {
    return;
  }

  virtualModulesInstance = new VirtualModules(modules);
  encore.addPlugin(virtualModulesInstance);
  logTitle('Virtual wrapper modules enabled', COLORS.green);
}

function sanitizeRelativeDir(relativePath = '') {
  if (!relativePath) {
    return '';
  }

  const dir = path.dirname(relativePath);
  return dir === '.' ? '' : dir;
}

function toPosix(filePath) {
  return filePath.split(path.sep).join('/');
}

function getWrapperTemplate() {
  if (!wrapperTemplateContent) {
    wrapperTemplateContent = fs.readFileSync(WRAPPER_TEMPLATE_PATH, 'utf8');
  }

  return wrapperTemplateContent;
}

function renderWrapperTemplate(classPath, className) {
  return getWrapperTemplate()
    .replace(/{classPath}/g, classPath)
    .replace(/{className}/g, className);
}

function buildEncoreConfig(options = {}) {
  if (options.clearCache !== false) {
    execSync('php bin/console cache:clear --no-warmup', {stdio: 'inherit'});
  }

  maybeGenerateEncoreManifest(options);
  configureEncoreBase(options);
  applyManifestEntries(options);

  return Encore.getWebpackConfig();
}

module.exports = {
  DEFAULT_MANIFEST_PATH,
  configureEncoreBase,
  applyManifestEntries,
  loadManifest,
  buildEncoreConfig,
};
